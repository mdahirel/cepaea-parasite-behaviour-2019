---
title: 'main analysis code for "Morph-dependent effect of nematode infection on host movement in the land snail *Cepaea nemoralis* (Mollusca, Gastropoda)"'
author: "Maxime Dahirel, Marine Proux, Armelle Ansart, Claudia Gérard (this code by M. Dahirel)"
date:
output: 
  html_document:
    theme: yeti
    toc: TRUE
    toc_float: TRUE
editor_options:
  chunk_output_type: console
bibliography:
csl:
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, message = FALSE)
```

# A brief introduction

This code is used for analyzing data collected during Marine Proux's internshio in 2019. This was a study of how different morphs of *Cepaea nemoralis* varied in their behaviour and in the parasites they naturally harbour, and whether there was a link between parasitism and behaviour (see more details in the manuscript). 180 snails were tested, minus one that died during the experiments (it is still in the dataset)

# Part 1 : Preparation

## 1A - packages

```{r packages-loading}
library(matrixStats) # CRAN v0.61.0

library(cmdstanr) # [github::stan-dev/cmdstanr] v0.4.0.9000
library(brms) # CRAN v2.16.3

library(tidyverse) # CRAN v1.3.1

library(bayesplot) # CRAN v1.8.1
library(tidybayes) # CRAN v3.0.2

library(patchwork) # CRAN v1.1.1

library(here) # CRAN v1.0.1

options(mc.cores = 4) ## to reduce/increase depending on cores available on your machine
```

## 1B – data loading

We start by loading the raw data, which are presented as two separate files: `raw_behaviour` and `raw_parasite`. This is because behaviours are measured twice while parasites once.

```{r data-load}
raw_behaviour <- read_csv(here("data", "cepaea_2019_behaviour.csv"))
raw_parasite <- read_csv(here("data", "cepaea_2019_parasite.csv"))
```

Variables common to both datasets (typically encoding general characteristics of the populations and individuals) are:

- `population`: two levels, "shaded" or "sun_exposed" (see main text for details about each population);

- `series`: snails were split in three experimental groups that started the experiment each at a different time (see manuscript). This variable identifies the experimental group the snail belongs to;

- `group`: a dummy variable related to the ID code written on each snail. !!! Not to be confused with `series` or `session`;

- `fullID`: unique individual identifier;

- `band_number`: whether a snail has 0, 3 or 5 bands on its shell (categorical variable);

- `fusion`: whether bands are fused, if there are bands present;

- `shell_diameter`: greatest shell diameter, in mm;

- `total_mass` (in g): recorded at the same time as shell diameter, but was not used in further analyses due to the high within-individual variability of water content and the *a priori* unknown contributions of parasites to total mass;

- `shell_mass` (in g);

- `dead`(binary): whether the individual died before the end of the experiment.


Variables present in the `raw behaviour` dataset only:

- `session`: behaviours were observed twice for each individual. This variable tells us whether the observation was the first or the second one (not be confused with `series`);

- `FPT1`, `FPT2` and `FPT3`: time to cross different thresholds (First Passage Time) during the movement trials. `FPT1` is the time to move 2cm away from starting point (we actually don't count snails as active before they crossed that threshold), `FPT2` and `FPT3` are 5 and 10 cm away (largest possible value is 1200 seconds, since observations were stopped after 20 min);

- `Food_intake`: Quantity of food consumed (out of 1.5 g) during food intake tests.


Variables present in the `raw parasite` dataset only:

- `Nematode_0_1_free`, `Nematode_1_3_free`, `Nematode_3_5_free`, `Nematode_5_plus_free`: counts of nematode (unidentified) found free between the shell and the body of snails. Nematodes of different size classes were counted separately, respectively <1mm long, between 1 and 3 mm, between 3 and 5 mm, longer than 5 mm (all live nematodes are pooled later and these sub-counts are not used here);

- `Nematode_1_3_lung`, `Nematode_3_5_lung`, `Nematode_5_plus_lung`: same as above, for nematodes found in the lung;

- `Nematode_white_encaps`, `Nematode_dark_encaps`: counts of nematodes found trapped, encapsulated in the snail's shell. Counts are split between nematodes found trapped in the light vs dark parts of the shell;

- `Acari_kidney`, `Acari_digestive`: mites found in the kidney and digestive gland of snails;  

- `Acari_encaps`: encapsulated mites; 

- `Trematode_kidney`: trematodes found in the kidney (all were *Brachylaima* metacercariae).


## 1C – data cleaning and preparation

Now that raw data are loaded, we can start to prep them for the analyses.

First, during data entry, nematodes were divided by size class (live ones) and whether they were found on dark or light parts of the shells (encapsulated). For the analysis we will need to sum all the live nematodes together and all the encapsulated ones together (same for the mites):

```{r data-prep1}
data_parasite <- raw_parasite %>%
  mutate(population = fct_relevel(factor(population), "shaded", after = Inf)) %>% # factor reordering
  mutate(Nematode_live_all = Nematode_0_1_free + Nematode_1_3_free +
           Nematode_3_5_free + Nematode_5_plus_free + Nematode_1_3_lung + 
           Nematode_3_5_lung + Nematode_5_plus_lung,
         Nematode_encaps_all = Nematode_white_encaps + Nematode_dark_encaps,
         Acari_live_all = Acari_kidney + Acari_digestive
         ) %>% 
  mutate(session = 1)
```

we then merge this with the behaviour dataset, and remove the dead snail here:

```{r data-prep2}
data <- raw_behaviour %>%
  mutate(population = fct_relevel(factor(population), "shaded", after = Inf)) %>%
  left_join(data_parasite) %>%
  filter(dead == 0)
```

In the new dataset, we then center and standardize the continuous variables. We do that in two steps. First, the easy ones, everything but movement:

```{r data-prep3}
data <- data %>%
  # we then standardize size and response variables
  mutate(
    scale_size = scale(shell_diameter)[, 1],
    scale_food = scale(Food_intake)[, 1]
  ) %>%
  mutate(
    mean_size = mean(shell_diameter, na.rm = TRUE), ## useful for back-transformations for plots
    sd_size = sd(shell_diameter, na.rm = TRUE)
  ) %>%
  mutate(
    mean_food = mean(Food_intake, na.rm = TRUE),
    sd_food = sd(Food_intake, na.rm = TRUE)
  )
```

We then prep the movement variable, which is a bit more complex. We first need to create our actual latency of move way variable, by removing the time unactive `FPT1` from the total response times `FPT3` before using them. We need to do that properly in particular for the individuals that did not move at all (because a naive `FPT3 - FPT1` when both are 1200sec (the maximum) gives 0, which is the wrong answer. Finally, as the survival model on the untransformed latencies doesn't work well (see below), we'll also prepare a variable that is the inverse latency to analyse with a Gaussian model (so we'll center and scale it too). 


```{r data-prep-mvt}
# we then define our movement variable
data <- data %>%
  mutate(
    FPT_2cm = FPT1 / 60, ## let's just convert them to minutes
    FPT_10cm = FPT3 / 60
  ) %>%
  mutate(is_active = FPT_2cm < 20) %>%  ## our indicator of which observations were just inactive snails
  mutate(latency = FPT_10cm - FPT_2cm) %>%
  mutate(moved_out = FPT_10cm <20) %>%  ## tells us if snails actually moved out
  mutate(mvt = 1 / latency) %>%
  mutate(
    latency = replace(latency, which(is_active == FALSE), 20),
    mvt = replace(mvt, which(is_active == FALSE), 0)
  ) %>%
  # put a zero mvt/ max latency for the ones that don't move, they will be excluded in-model anyway
  mutate(
    mean_mvt = mean(subset(mvt, is_active == TRUE)), ## mean and sd for scaling
    sd_mvt = sd(subset(mvt, is_active == TRUE))
  ) %>% ## exclude not moving individuals
  mutate(scale_mvt = (mvt - mean_mvt) / sd_mvt)
## individuals with fpt1>=20 minutes are NOT active, so should not count towards mvt model
## is time to activity (FPT1) itself actually a relevant variable? No (time spent in the Petri before putting them on the table was not standardised)
```


Then we're ready to move on to the analyses!!

# Part 2: analyses

First, some basic checks for the Methods. Here: how many snails have 2 valid movement data, 1 or 0 (because inactive during test):

```{r movement-counts}
data %>% group_by(fullID) %>% summarise(Nvalid_obs=sum(is_active)) %>% select(Nvalid_obs) %>% table()
```

## 2A: natural history of parasites

Here we collect some qualitative information about infections:

```{r parasite-quali-info}
# One individual is dead, how many nematodes did we find in it?
subset(data_parasite$Nematode_live_all, data_parasite$dead == 1)
# and trematodes?
subset(data_parasite$Trematode_kidney, data_parasite$dead == 1)
# by comparison, what is the highest number of nematodes and trematodes in live snails?
max(subset(data_parasite$Nematode_live_all, data_parasite$dead == 0))
max(subset(data_parasite$Trematode_kidney, data_parasite$dead == 0))

# who are the snails infected with Riccardoella mites
subset(data_parasite, data_parasite$Acari_live_all > 0)
# or that encapsulated some?
subset(data_parasite, data_parasite$Acari_encaps > 0)

# what is the proportion of snails that are currently infected yet show no encapsulation (to show that all infections may not show encapsulations):
table(
  paste("has encaps", data_parasite$Nematode_encaps_all > 0), 
  paste("has live nematodes", data_parasite$Nematode_live_all > 0)
  )
```

## 2B - univariate model for body size

```{r model-size}
mod_size <- brm(
  bf(scale_size ~ 0 + band_number + band_number:population), ## we use that notation throughout to have an intercept and a population effect per morph, rather than having morph contrasts
  data = subset(data, session == 1),
  # size variable is present twice in dataset (to go with behaviour)
  # subset argument ensures it is counted only once and we don't artificially double the dataset
  chains = 4, iter = 4000, warmup = 2000,
  prior = c(
    set_prior("normal(0,1)", class = "b"),
    set_prior("normal(0,1)", class = "sigma")
  ),
  backend = "cmdstanr", seed = 42, control = list(max_treedepth = 20)
)
```

Let's do some basic checks (list below not exhaustive, see vignettes of the `tidybayes` package)

```{r model-size-checks}
pp_check(mod_size,ndraws=100)
pp_check(mod_size, "stat_2d")
plot(mod_size)
mcmc_rank_hist(mod_size)
mcmc_rank_overlay(mod_size)
summary(mod_size)
plot(conditional_effects(mod_size))
```

Everything seems in order, let's move to the big parasite-behaviour model


## 2C - preparing the multivariate behaviour-parasite model

OK, before building the big multivariate model, let's check that the families we have in mind for each submodel are fine. The trematode and nematode submodels should be OK (we'll still check them later), let's focus our effort on the movement and food intake model.

First, our food intake submodel. Food intake is a proportion of the total food given, so a Beta model should be natural. There are few zeroes which could be a problem, but we can solve that by setting them to the detection limit of our balance and using left-censoring (so we say that all we know is that they ate below the 0.0001g detection threshold). Let's try:

```{r food-model-test}
data_test <- data %>%
  mutate(food_test = replace(Food_intake, which(Food_intake == 0), 0.0001))


mod_food_test_beta <- brm(
  bf(food_test / 1.5 | cens(-1 * (food_test <= 0.0001)) ~ # we use left-censoring to allow zero values in a Beta model
  # in effect we assume that zeroes are actually non-zeroes but below the scale detection limit
  0 + band_number + band_number:population +
    scale_size + (1 | series) + (1 | fullID)),
  family = Beta,
  data = data_test, chains = 4, iter = 4000, warmup = 2000,
  prior = c(
    set_prior("normal(0,1)", class = "b"),
    set_prior("normal(0,1)", class = "sd")
  ),
  backend = "cmdstanr", seed = 42, control = list(adapt_delta = 0.99, max_treedepth = 15)
)

pp_check(mod_food_test_beta,ndraws=100)
pp_check(mod_food_test_beta,"stat_2d")
```

The Beta model inflates variance a lot compared to data.

Let's just be simple and try a Gaussian LMM?

```{r food-model-test2}
mod_food_test_normal <- brm(
  bf(scale_food ~
  0 + band_number + band_number:population +
    scale_size + (1 | series) + (1 | fullID)),
  data = data, chains = 4, iter = 4000, warmup = 2000,
  prior = c(
    set_prior("normal(0,1)", class = "b"),
    set_prior("normal(0,1)", class = "sd")
  ),
  backend = "cmdstanr", seed = 42, control = list(adapt_delta = 0.99, max_treedepth = 15)
)

pp_check(mod_food_test_normal,ndraws=100)
```

It's much better (there may be some divergence diagnostics. We should usually worry about them a bit more, but they are absent from the final big multivariate model below, which is the model we are interested in).


We do the same sort of tests for the movement submodel. Let's try a fairly typical survival model first: lognormal on the untransformed latencies, with the non-active snails excluded, and the active snails that were not fast enough to move out before the end of the experiment right-censored:

```{r mod-mvt-test-lognormal}

mod_mvt_test_lognormal <- brm(
  bf(latency | subset(is_active == TRUE) + ## we exclude non-moving snails
    cens(FPT_10cm >= 20) ~ 0 + band_number + band_number:population +
    scale_size + (1 | series) + (1 | fullID)),
  family = lognormal,
  data = data, chains = 4, iter = 2000, warmup = 1000,
  prior = c(
    set_prior("normal(0,1)", class = "b"),
    set_prior("normal(0,1)", class = "sd"),
    set_prior("normal(0,1)", class = "sigma")
  ),
  backend = "cmdstanr", seed = 42, control = list(adapt_delta = 0.99, max_treedepth = 15)
)
```

We check whether the model predictions match the data distributions (we can't use the general `pp_check()` wrappers and have to write everything manually because of the censored data, but that's the same thing)

```{r mod-mvt-test-lognormal-ppchecks}
newdata <- subset(data, is_active == TRUE)
ppc_stat_2d(
  yrep = (predict(mod_mvt_test_lognormal, newdata = newdata, summary = FALSE)[1:100, ]),
  y = newdata$latency
)

ppc_dens_overlay(
  yrep = (predict(mod_mvt_test_lognormal, newdata = newdata, summary = FALSE)[1:100, ]),
  y = newdata$latency
)
```

Like with the food model, something is off (it is easy _ not shown _ to change the model family from lognormal to Gamma with a log link, for instance, and see that it doesn't change much).

So, let's try a Gaussian model on inverse latency data instead:

```{r mod-mvt-test-gaussian}

mod_mvt_test_normal <- brm(
  bf(scale_mvt | subset(is_active == TRUE) ~ ## we exclude non-moving snails
  0 + band_number + band_number:population +
    scale_size + (1 | series) + (1 | fullID)),
  data = data, chains = 4, iter = 2000, warmup = 1000,
  prior = c( # priors are probably bad but this is just for testing
    set_prior("normal(0,1)", class = "b"),
    set_prior("normal(0,1)", class = "sd"),
    set_prior("normal(0,1)", class = "sigma")
  ),
  backend = "cmdstanr", seed = 42, control = list(adapt_delta = 0.99, max_treedepth = 15)
)

pp_check(mod_mvt_test_normal,ndraws=100)
```

This looks way better. Note that the even better approach would be to add left-censoring to the few active-but-did-not-cross the border snails (because their movement is low we don't really know how low):

```{r mod-mvt-test-gaussian2}
mod_mvt_test_normal2 <- brm(
  bf(scale_mvt | subset(is_active == TRUE) + cens(-1 * (moved_out==FALSE))~ ## we exclude non-moving snails
  0 + band_number + band_number:population +
    scale_size + (1 | series) + (1 | fullID)),
  data = data, chains = 4, iter = 2000, warmup = 1000,
  prior = c( # priors are probably bad but this is just for testing
    set_prior("normal(0,1)", class = "b"),
    set_prior("normal(0,1)", class = "sd"),
    set_prior("normal(0,1)", class = "sigma")
  ),
  backend = "cmdstanr", seed = 42, control = list(adapt_delta = 0.99, max_treedepth = 15)
)

```

but the outcome of the two models are nearly identical:

```{r mod-mvt-test-gaussian3}
summary(mod_mvt_test_normal)
summary(mod_mvt_test_normal2)
```

so we're going with the simplest for the big analysis.

(they're nearly identical first because there aren't that many observations where individuals were active but didn't leave)

```{r test-how-many-slow-snails}
table(paste("is it active?",data$is_active),paste("did it move beyond 10cm?",data$moved_out))
```

(and second because these individuals already had the highest recorded latencies, so their inverse latencies are already low) (They're not for instance, individuals that started to be active minute 19 out of 20 so had no time to move out. They're individuals that became active at the same time as the others, but stayed within the 10 cm radius circle)

```{r test-how-many-slow-snails2}
ggplot(data)+
  geom_histogram(aes(FPT_2cm))+
  scale_x_continuous("latency to become active (min)")
  facet_wrap(~paste("is it active,",is_active)+paste("did it move beyond 10 cm?",moved_out))

ggplot(data)+
  geom_histogram(aes(latency))+
  scale_x_continuous("latency to leave the 10cm *after one became active* (min)")+
  facet_wrap(~paste("is it active,",is_active)+paste("did it move beyond 10 cm?",moved_out))
```

## 2D - actually doing the multivariate model

We start by writing the model formulas for each variable:

```{r multi-model-formulas}
bf_trema <- bf(Trematode_kidney | subset(session == 1) ~  # for the parasite submodels, we subset to avoid duplication (see above in size model)
  0 + band_number + band_number:population + scale_size +
    (1 | series) + (1 | q | fullID),
  family = poisson
)

bf_nema_live <- bf( Nematode_live_all | subset(session == 1 & population == "sun_exposed") ~ 
                      # no nematode in the shaded population
  0 + band_number + scale_size +
    (1 | series) + (1 | q | fullID),
  family = poisson
  )

bf_food <- bf(scale_food ~
                0 + band_number + band_number:population + scale_size +
                (1 | series) + (1 | q | fullID),
              family=gaussian
              )

bf_mvt <- bf(scale_mvt | subset(is_active == TRUE) ~ # we exclude the non-active observations
     0 + band_number + band_number:population + scale_size +
    (1 | series) + (1 | q | fullID),
  family = gaussian
  )
```

(note the notation of the individual random effect 1|q|fullID, the q is here to denote that the random effects belong to the same covariance matrix)

Then we write the priors:

```{r multi-model-priors}
prior <- c(
    set_prior("normal(0,1)",
      class = "b",
      resp = c("Trematodekidney", "Nematodeliveall", "scalefood", "scalemvt")
    ),
    set_prior("normal(0,1)",
      class = "sd",
      resp = c("Trematodekidney", "Nematodeliveall", "scalefood", "scalemvt")
    ),
    set_prior("normal(0,1)", class = "sigma", resp = c("scalemvt", "scalefood")),
    set_prior("lkj(2)", class = "cor")
  )
```

Then we build the model:

```{r multi-model}
mod_multi <- brm(mvbf(bf_food + bf_trema + bf_nema_live + bf_mvt),
  data = data,
  chains = 4, iter = 4000, warmup = 2000,
  prior = prior,
  backend = "cmdstanr", seed = 42, 
  control = list(adapt_delta = 0.99, max_treedepth = 10)
)

summary(mod_multi)

## check that the subset arguments behaved correctly: there should be no NA-related warnings despite NAs in the dataset
## (because they've been "subsetted out")
## and the number of observations at the top of the summary should be = to the size of the dataset
```

Fits fast and without major problems. Let's do some other checks:

```{r multi-model-ppchecks}
pp_check(mod_multi,resp="scalefood",ndraws=100)
pp_check(mod_multi,resp="Nematodeliveall",ndraws=100)
pp_check(mod_multi,resp="Trematodekidney",ndraws=100)
pp_check(mod_multi,resp="scalemvt",ndraws=100)
```

Now we can move to building the tables and the figures

# Part 3 - figures, tables and other useful outputs

## Figure 1 - body size

First we generate predictions for size. We create a table containing the 6 combinations of bands and population, and we add to it the predictions, and then we back-transform them using the stored means and SD:

```{r preds-size}
preds_size <- data %>%
  select(band_number, population, mean_size, sd_size) %>%
  distinct() %>%
  mutate(session = 1) %>%
  add_epred_draws(mod_size) %>%
  ungroup() %>%
  mutate(population = fct_recode(population,
    `shaded habitat` = "shaded",
    `open habitat` = "sun_exposed"
  )) %>%
  mutate(.value = (.epred * sd_size) + mean_size) # we back-transform
```

We use these predictions to look at differences between morphs and populations

```{r compare-size}

preds_size %>%
  mutate(.iteration = .draw) %>%
  group_by(population) %>%
  compare_levels(variable = .value, by = band_number) %>%
  mean_hdi()


preds_size %>%
  mutate(.iteration = .draw) %>%
  group_by(band_number) %>%
  compare_levels(variable = .value, by = population) %>%
  mean_hdi()
```

And we plot them alongside the observed size values:

```{r fig1-size}
ggplot(subset(data, dead == 0 & session == 1) %>%
  mutate(population = fct_recode(population,
    `shaded habitat` = "shaded",
    `open habitat` = "sun_exposed"
  ))) +
  geom_jitter(aes(band_number, shell_diameter), 
              height = 0, col = "grey") +
  stat_eye(data = preds_size, 
           aes(band_number, .value, fill = band_number), 
           .width = c(0.01, 0.95), 
           slab_alpha = 0.7) +
  scale_y_continuous("Shell diameter (mm)") +
  scale_x_discrete("Shell phenotype (band number)", labels = c("0 bands", "3 bands", "5 bands")) +
  scale_fill_manual(values = c("#fe9929", "#d95f0e", "#993404")) +
  facet_wrap(~population) +
  cowplot::theme_half_open(11) +
  cowplot::background_grid(colour.major = "grey95", colour.minor = "grey95") +
  theme(legend.position = "none")
```

## Figure 3 - parasite info

(no Figure 2 from code; it is made of photographs)


That figure is made of three parts: one for the encapsulated nematodes (no stats, no counts, we just want to have an idea about presence), one for the live nematodes, one for the live trematodes.

### Encapsulated nematodes

That subfigure is just the presence/absence of encapsulated nematodes in shells. We didn't do stats, and we don"t use counts, for the same reasons: contrary to live parasites that can be cleared, encapsulated parasites accumulate with age. So unless we know snails' age, which we don't, we can't do meaningful analyses. But having a broad qualitative idea of how many adults have had an encounter is useful:

```{r fig-encaps}

p_encaps <- data_parasite %>%
  filter(dead == 0) %>%
  mutate(population = fct_recode(population,
    `shaded habitat` = "shaded",
    `open habitat` = "sun_exposed"
  )) %>%
  group_by(population, band_number) %>%
  summarise(percent_encaps = mean(Nematode_encaps_all > 0) * 100) %>% 
  ungroup() %>%
  ggplot() +
  geom_col(aes(band_number, percent_encaps), fill = "white", col = "grey") +
  scale_y_continuous("% with encapsulated nematodes") +
  scale_x_discrete("", labels = c("0 bands", "3 bands", "5 bands")) +
  facet_wrap(~population) +
  coord_cartesian(ylim = c(0, 100))
```

Then we do the live nematode subfigure. Like with size, we create predictions first, then plot them alongside observations (note that there is no predictions for the shaded population, since there were no nematodes)

```{r fig-nematodes}
preds_nematode <- data %>%
  select(band_number) %>%
  distinct() %>%
  mutate(scale_size = 0, session = 1, population = "sun_exposed") %>%
  add_epred_draws(mod_multi, re_formula = NA, resp = "Nematodeliveall") %>%
  ungroup() %>%
  mutate(population = fct_recode(population, `open habitat` = "sun_exposed"))

p_nema <- ggplot(subset(data, dead == 0 & session == 1) %>%
  mutate(population = fct_recode(population,
    `shaded habitat` = "shaded",
    `open habitat` = "sun_exposed"
  ))) +
  geom_jitter(aes(band_number, Nematode_live_all), 
              height = 0, col = "grey") +
  stat_eye(data = preds_nematode, 
           aes(band_number, .epred, fill = band_number), 
           .width = c(0.01, 0.95), slab_alpha = 0.7, 
           point_interval = mean_hdi) +
  scale_y_continuous("Nematodes") +
  scale_x_discrete("", labels = c("0 bands", "3 bands", "5 bands")) +
  scale_fill_manual(values = c("#fe9929", "#d95f0e", "#993404")) +
  facet_wrap(~population)
```

and we do the same for trematodes (which were found in both populations):

```{r fig-trematodes}
preds_trematode <- data %>%
  select(band_number, population) %>%
  distinct() %>%
  mutate(scale_size = 0, session = 1) %>%
  add_epred_draws(mod_multi, re_formula = NA, resp = "Trematodekidney") %>%
  ungroup() %>%
  mutate(population = fct_recode(population,
    `shaded habitat` = "shaded",
    `open habitat` = "sun_exposed"
  ))

p_trema <- ggplot(subset(data, dead == 0 & session == 1) %>%
  mutate(population = fct_recode(population,
    `shaded habitat` = "shaded",
    `open habitat` = "sun_exposed"
  ))) +
  geom_jitter(aes(band_number, Trematode_kidney), 
              height = 0, col = "grey") +
  stat_eye(data = preds_trematode, 
           aes(band_number, .epred, fill = band_number), 
           .width = c(0.01, 0.95), slab_alpha = 0.7, 
           point_interval = mean_hdi) +
  scale_y_continuous("Trematodes") +
  scale_x_discrete("Shell phenotype (band number)", 
                   labels = c("0 bands", "3 bands", "5 bands")) +
  scale_fill_manual(values = c("#fe9929", "#d95f0e", "#993404")) +
  facet_wrap(~population)
```

We can then put the pieces of the puzzle together:

```{r fig2}
p_encaps / p_nema / p_trema &
  cowplot::theme_half_open(11) &
  cowplot::background_grid(colour.major = "grey95", colour.minor = "grey95") &
  theme(legend.position = "none") &
  plot_annotation(tag_levels = "A")
```

We can then do comparisons among groups (since they're counts, let's do multiplicative comparisons, ratios between counts)

```{r parasite-comparisons}
preds_nematode %>%
  mutate(group = paste(band_number, ", ", population, sep = "")) %>%
  compare_levels(.epred, by = group, fun = `/`) %>%
  mean_hdi()

preds_trematode %>%
  mutate(group = paste(band_number, ", ", population, sep = "")) %>%
  compare_levels(.epred, by = group, fun = `/`) %>%
  mean_hdi()

```


## Figure 4 - behaviour info

```{r}
preds_mvt <- data %>%
  select(population, band_number, mean_mvt, sd_mvt) %>%
  distinct() %>%
  mutate(scale_size = 0, session = 1, has_moved = TRUE) %>%
  add_fitted_draws(mod, re_formula = NA, resp = "scalemvt") %>%
  ungroup() %>%
  mutate(population = fct_recode(population,
    `shaded habitat (no nematodes)` = "shaded",
    `open habitat (nematodes)` = "sun_exposed"
  ))


p_mvt <- ggplot(subset(data, has_moved == TRUE) %>%
  mutate(population = fct_recode(population,
    `shaded habitat (no nematodes)` = "shaded",
    `open habitat (nematodes)` = "sun_exposed"
  ))) +
  geom_line(aes(as.numeric(factor(band_number)) + 0.5 * session - 0.75, scale_mvt, group = fullID), col = "grey") +
  geom_point(aes(band_number, scale_mvt, pch = FPT3 == 20, group = session), position = position_dodge(width = 1), col = "grey", fill = "white") +
  stat_eye(
    data = preds_mvt, aes(band_number, .value, fill = band_number),
    .width = c(0.01, 0.95), slab_alpha = 0.7, point_interval = mean_hdi
  ) +
  scale_shape_manual(values = c(16, 21)) +
  scale_fill_manual(values = c("#fe9929", "#d95f0e", "#993404")) +
  scale_y_continuous("Movement (standardised)") +
  scale_x_discrete("", labels = c("0 bands", "3 bands", "5 bands")) +
  facet_wrap(~population)



preds_food <- data %>%
  select(population, band_number, mean_food, sd_food) %>%
  distinct() %>%
  mutate(scale_size = 0, session = 1, fusion = "no") %>%
  add_fitted_draws(mod, re_formula = NA, resp = "scalefood") %>%
  mutate(.value = .value * sd_food + mean_food) %>%
  ungroup() %>%
  mutate(population = fct_recode(population,
    `shaded habitat (no nematodes)` = "shaded",
    `open habitat (nematodes)` = "sun_exposed"
  ))

p_food <- ggplot(data %>%
  mutate(population = fct_recode(population,
    `shaded habitat (no nematodes)` = "shaded",
    `open habitat (nematodes)` = "sun_exposed"
  ))) +
  geom_point(aes(band_number, Food_intake, group = session), position = position_dodge(width = 1), col = "grey") +
  geom_line(aes(as.numeric(factor(band_number)) + 0.5 * session - 0.75, Food_intake, group = fullID), col = "grey") +
  stat_eye(
    data = preds_food, aes(band_number, .value, fill = band_number),
    .width = c(0.01, 0.95), slab_alpha = 0.7, point_interval = mean_hdi
  ) +
  scale_fill_manual(values = c("#fe9929", "#d95f0e", "#993404")) +
  scale_y_continuous("Food intake (g/night)") +
  scale_x_discrete("Shell phenotype (band number)", labels = c("0 bands", "3 bands", "5 bands")) +
  facet_wrap(~population)

p_mvt / p_food &
  cowplot::theme_half_open(11) &
  cowplot::background_grid(colour.major = "grey95", colour.minor = "grey95") &
  theme(legend.position = "none") &
  plot_annotation(tag_levels = "A")
```


## Table 1 - multivariate model summary

```{r}
summary_mod <- mod %>%
  posterior_samples() %>%
  select(starts_with(c("Intercept", "b_", "sd_", "cor_fullID", "sigma"))) %>%
  pivot_longer(everything()) %>%
  group_by(name) %>%
  mean_hdi()

summary_mod %>%
  print(n = Inf)


table1 <- summary_mod %>%
  mutate(value = paste(round(value, 2), " [", round(.lower, 2), "; ", round(.upper, 2), "]", sep = "")) %>%
  filter(str_detect(name, "cor_fullID") == FALSE) %>%
  mutate(trait = case_when(
    str_detect(name, "Nematode") ~ "Nematode abundance",
    str_detect(name, "Trematode") ~ "Trematode abundance",
    str_detect(name, "food") ~ "Food intake",
    str_detect(name, "scalemvt") ~ "Movement",
    TRUE ~ "ERROR"
  )) %>%
  mutate(coefficient = case_when(
    str_detect(name, "sigma") ~ "Residual SD",
    str_detect(name, "sd_series") ~ "Test group SD",
    str_detect(name, "sd_fullID") ~ "Individual-level SD",
    str_detect(name, "size") ~ "Shell size (standardised)",
    str_detect(name, "5B:populationshaded") ~ "Population = \"shaded\"~[5 bands]~",
    str_detect(name, "3B:populationshaded") ~ "Population = \"shaded\"~[3 bands]~",
    str_detect(name, "0B:populationshaded") ~ "Population = \"shaded\"~[0 bands]~",
    str_detect(name, "5B$") ~ "Intercept~[5 bands]~",
    str_detect(name, "3B$") ~ "Intercept~[3 bands]~",
    str_detect(name, "0B$") ~ "Intercept~[0 bands]~",
  )) %>%
  select(coefficient, trait, value) %>%
  pivot_wider(names_from = "trait", values_from = "value") %>%
  select(coefficient, `Nematode abundance`, `Trematode abundance`, `Movement`, `Food intake`) %>%
  unnest(cols = c())

table1[c(1, 2, 3, 5, 6, 7, 4, 9, 8, 10), ] %>% # just some reordering
  knitr::kable()
```


## Table 2 - multivariate model correlation table

```{r}
table2 <- summary_mod %>%
  mutate(value = paste(round(value, 2), " [", round(.lower, 2), "; ", round(.upper, 2), "]", sep = "")) %>%
  filter(str_detect(name, "cor_fullID") == TRUE) %>%
  mutate(
    response1 = case_when(
      str_detect(name, "cor_fullID__Nematode") ~ "Nematode abundance",
      str_detect(name, "cor_fullID__scalefood") ~ "Food intake",
      str_detect(name, "cor_fullID__Trematode") ~ "Trematode abundance",
      str_detect(name, "cor_fullID__scalemvt") ~ "Movement"
    ),
    response2 = case_when(
      str_detect(name, "Nematodeliveall_Intercept$") ~ "Nematode abundance",
      str_detect(name, "scalefood_Intercept$") ~ "Food intake",
      str_detect(name, "Trematodekidney_Intercept$") ~ "Trematode abundance",
      str_detect(name, "scalemvt_Intercept$") ~ "Movement"
    )
  ) %>%
  select(response1, response2, value)

table2

## here we're going to sort manually in manuscript, so we can match the order in table 1

# mcmc_rank_overlay(mod, pars = summary_mod$name)
```


```{r}

preds_mvt %>%
  mutate(group = paste(band_number, ", ", population, sep = "")) %>%
  compare_levels(.value, by = group) %>%
  mean_hdi()

preds_food %>%
  mutate(group = paste(band_number, ", ", population, sep = "")) %>%
  compare_levels(.value, by = group) %>%
  mean_hdi()
```

## Some other useful outputs

```{r}
# a plot to look at the size of the dead snail relative to the others
ggplot(data_parasite) +
  geom_boxplot(aes(band_number, shell_diameter)) +
  geom_point(
    data = subset(data_parasite, dead == 1),
    aes(band_number, shell_diameter), col = "red", size = 2
  ) +
  facet_wrap(~population)
```

